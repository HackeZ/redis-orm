{{define "object.order.by"}}
{{$order := .}}
type {{$order.Name}}OrderBy struct{
	{{- range $j, $field := $order.Fields}}
		{{$field.Name}} {{$field.GetType}}
	{{- end}}
	offset int
	limit int
	ascend bool
}

func (u *{{$order.Name}}OrderBy) Key() string {
	strs := []string{
		{{- range $j, $field := $order.Fields}}
			{{- if eq (add $j 1) (len $order.Fields)}}
				"{{$field.Name}}",
			{{- else}}
				"{{$field.Name}}",
				fmt.Sprint(u.{{$field.Name}}),
			{{- end}}
		{{- end}}
	}
	return fmt.Sprintf("orderby:%s", strings.Join(strs, ":"))
}

func (u *{{$order.Name}}OrderBy) sortOp() string {
	if u.ascend {
		return "ASC"
	}
	return "DESC"
}

func (u *{{$order.Name}}OrderBy) SQLFormat() string {
	conditions := []string{}

	{{- range $j, $field := $order.Fields}}
		{{- if eq (add $j 1) (len $order.Fields)}}
		sortstr := fmt.Sprintf(" ORDER BY {{$field.Name | camel2name}} %s ", u.sortOp())
		{{- else}}
		conditons = append(conditons, "{{$field.Name | camel2name}} = ?")
		{{- end}}		
	{{- end}}
	return fmt.Sprintf("%s %s %s", strings.Join(conditions, " AND "), sortstr, orm.OffsetLimit(u.offset, u.limit))
}

func (u *{{$order.Name}}OrderBy) SQLParams() []interface{} {
	return []interface{}{
		{{- range $j, $field := $order.Fields}}
		u.{{$field.Name}},
		{{- end}}
	}
}

func (u *{{$order.Name}}OrderBy) SQLLimit() int {
	if u.limit > 0 {
		return u.limit	
	}
	return -1
}

func (u *{{$order.Name}}OrderBy) Limit(n int) {
	u.limit = n
}

func (u *{{$order.Name}}OrderBy) Offset(n int) {
	u.offset = n
}

func (u *{{$order.Name}}OrderBy) Ascend(f bool) {
	u.ascend = f
}
{{end}}
