{{define "object.range"}}
{{$rg := .}}
type {{$rg.Name}}Range struct{
	{{- range $j, $field := $rg.Fields}}
		{{- if eq (add $j 1) (len $rg.Fields)}}
		{{$field.Name}}Begin {{$field.GetType}}
		{{$field.Name}}End {{$field.GetType}}
		{{- else}}
		{{$field.Name}} {{$field.GetType}}
		{{- end}}
	{{- end}}
	offset int
	limit int
	includeBegin bool
	includeEnd bool
}
func (u *{{$rg.Name}}Range) Key() string {
	strs := []string{
		{{- range $j, $field := $rg.Fields}}
			{{- if eq (add $j 1) (len $rg.Fields)}}
				"{{$field.Name}}",
			{{- else}}
				"{{$field.Name}}",
				fmt.Sprint(u.{{$field.Name}}),
			{{- end}}
		{{- end}}
	}
	return fmt.Sprintf("range:%s", strings.Join(strs, ":"))
}

func (u *{{$rg.Name}}Range) beginOp() string {
	if u.includeBegin {
		return ">="
	}
	return ">"
}
func (u *{{$rg.Name}}Range) endOp() string {
	if u.includeBegin {
		return "<="
	}
	return "<"
}

func (u *{{$rg.Name}}Range) SQLFormat() string {
	conditions := []string{}
		{{- range $j, $field := $rg.Fields}}
			{{- if eq (add $j 1) (len $rg.Fields)}}
				conditions = append(conditions, fmt.Sprintf("{{$field.Name | camel2name}} %s ?", u.beginOp()))
				conditions = append(conditions, fmt.Sprintf("{{$field.Name | camel2name}} %s ?", u.endOp()))
			{{- else}}
				conditions = append(conditions, "{{$field.Name | camel2name}} = ?")
			{{- end}}		
		{{- end}}
	return fmt.Sprintf("%s %s", strings.Join(conditions, " AND "), orm.OffsetLimit(u.offset, u.limit))
}

func (u *{{$rg.Name}}Range) SQLParams() []interface{} {
	return []interface{}{
		{{- range $j, $field := $rg.Fields}}
			{{- if eq (add $j 1) (len $rg.Fields)}}
				u.{{$field.Name}}Begin,
				u.{{$field.Name}}End,
			{{- else}}
				u.{{$field.Name}},
			{{- end}}
		{{- end}}
	}
}

func (u *{{$rg.Name}}Range) SQLLimit() int {
	if u.limit > 0 {
		return u.limit	
	}
	return -1
}

func (u *{{$rg.Name}}Range) Limit(n int) {
	u.limit = n
}

func (u *{{$rg.Name}}Range) Offset(n int) {
	u.offset = n
}

func (u *{{$rg.Name}}Range) IncludeBegin(f bool) {
	u.includeBegin = f
}

func (u *{{$rg.Name}}Range) IncludeEnd(f bool) {
	u.includeEnd = f
}
{{end}}
